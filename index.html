<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GPT-4.1 Reasoning Studio</title>
  
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Marked.js for Markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <!-- Highlight.js for code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  
  <!-- Configuration for Tailwind -->
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: {
              50: '#eef2ff',
              100: '#e0e7ff',
              200: '#c7d2fe',
              300: '#a5b4fc',
              400: '#818cf8',
              500: '#5686f5', // Primary accent color
              600: '#4f46e5',
              700: '#4338ca',
              800: '#3730a3',
              900: '#312e81',
              950: '#1e1b4b',
            },
            dark: {
              100: '#d1d5db',
              200: '#9ca3af',
              300: '#6b7280',
              400: '#4b5563',
              500: '#374151',
              600: '#1f2937',
              700: '#111827',
              800: '#0d1117',
              900: '#030712',
            }
          },
          fontFamily: {
            sans: ['Inter', 'ui-sans-serif', 'system-ui', 'sans-serif'],
            mono: ['JetBrains Mono', 'ui-monospace', 'monospace'],
          },
        }
      }
    };
  </script>

  <style>
    /* Base Styles */
    :root {
      --primary: #5686f5;
      --primary-hover: #4169e1;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
    }
    
    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgb(20, 24, 33);
      border-radius: 8px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(86, 134, 245, 0.6);
      border-radius: 8px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(86, 134, 245, 0.8);
    }

    /* Thinking Steps Animation */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .thinking-steps {
      animation: fadeIn 0.3s ease;
    }
    
    /* Reflection Step Animation */
    @keyframes reflectionPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .reflection-step .step-number {
      animation: reflectionPulse 2s infinite;
    }
    
    /* Streaming Indicator Animation */
    @keyframes typingAnimation {
      0% { border-right-color: rgba(86, 134, 245, 0.7); }
      100% { border-right-color: transparent; }
    }
    
    .streaming {
      border-right: 3px solid rgba(86, 134, 245, 0.7);
      animation: typingAnimation 0.8s infinite ease;
    }
    
    @keyframes ellipsisAnimation {
      0% { content: "."; }
      33% { content: ".."; }
      66% { content: "..."; }
      100% { content: "."; }
    }
    
    .streaming-indicator::after {
      content: "...";
      animation: ellipsisAnimation 1.5s infinite;
    }

    /* Range Slider Styling */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 4px;
      background: #1f2937;
      border-radius: 4px;
      outline: none;
      background: linear-gradient(to right, var(--primary) var(--value-percent, 50%), #1f2937 var(--value-percent, 50%)) !important;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: white !important;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid rgba(0, 0, 0, 0.1) !important;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      margin-top: -6px;
    }
  </style>
</head>
<body class="bg-dark-800 text-gray-100 font-sans min-h-screen overflow-hidden">
  <div class="flex h-screen">
    <!-- Sidebar -->
    <div class="w-72 bg-dark-700 border-r border-dark-600 flex flex-col p-4 overflow-y-auto hidden md:flex">
      <h2 class="text-xl font-semibold mb-4">Threads</h2>
      <ul id="threadList" class="flex-1 space-y-1 mb-4">
        <li class="bg-dark-600 text-primary-300 px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition">Thread 1</li>
      </ul>
      <div class="space-y-2">
        <button id="newThreadBtn" class="w-full bg-primary-500 hover:bg-primary-600 text-white py-2 px-4 rounded-md transition flex items-center justify-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
          </svg>
          New Thread
        </button>
        <button id="deleteThreadBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Delete Thread</button>
        <button id="downloadTxtBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Download TXT</button>
        <button id="clearThreadBtn" class="w-full bg-red-600/20 hover:bg-red-600/30 text-red-400 py-2 px-4 rounded-md transition">Clear Thread</button>
      </div>
    </div>

    <!-- Mobile Sidebar Toggle -->
    <div id="mobileSidebarToggle" class="fixed left-4 top-4 bg-dark-700 p-2 rounded-md shadow-lg z-20 md:hidden">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
      </svg>
    </div>

    <!-- Mobile Sidebar -->
    <div id="mobileSidebar" class="fixed inset-0 bg-dark-800 z-30 transform -translate-x-full transition-transform duration-300 md:hidden">
      <div class="w-full h-full flex flex-col">
        <div class="flex justify-between items-center p-4 border-b border-dark-600">
          <h2 class="text-xl font-semibold">Threads</h2>
          <button id="closeMobileSidebar" class="p-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        <div class="flex-1 p-4 overflow-y-auto">
          <ul id="mobileThreadList" class="space-y-2 mb-4">
            <li class="bg-dark-600 text-primary-300 px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition">Thread 1</li>
          </ul>
          <div class="space-y-2">
            <button id="mobileNewThreadBtn" class="w-full bg-primary-500 hover:bg-primary-600 text-white py-2 px-4 rounded-md transition flex items-center justify-center gap-2">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
              </svg>
              New Thread
            </button>
            <button id="mobileDeleteThreadBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Delete Thread</button>
            <button id="mobileDownloadTxtBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Download TXT</button>
            <button id="mobileClearThreadBtn" class="w-full bg-red-600/20 hover:bg-red-600/30 text-red-400 py-2 px-4 rounded-md transition">Clear Thread</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-1 flex flex-col overflow-hidden">
      <!-- Header -->
      <header class="bg-dark-700 border-b border-dark-600 h-16 flex items-center justify-between px-4 md:px-6">
        <h1 id="pageTitle" class="text-xl font-semibold">GPT-4.1 Reasoning Studio</h1>
        <div class="flex items-center gap-3">
          <div id="currentModelDisplay" class="bg-dark-600 text-sm px-3 py-1.5 rounded-lg flex items-center">
            <span>gpt-4.1</span>
            <span class="bg-green-900/60 text-green-400 text-xs ml-2 px-2 py-0.5 rounded-full">Adaptive</span>
          </div>
          <button id="openSettings" class="flex items-center gap-1.5 bg-dark-600 hover:bg-dark-500 text-gray-300 px-3 py-1.5 rounded-lg transition">
            <span>Settings</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
            </svg>
          </button>
        </div>
      </header>

      <!-- Chat Messages Area -->
      <div id="chatMessages" class="flex-1 overflow-y-auto p-4 space-y-6"></div>

      <!-- Input Area -->
      <div class="p-4 border-t border-dark-600 bg-dark-700">
        <div class="flex items-start gap-3 rounded-xl bg-dark-600 p-3 shadow-lg border border-dark-500 focus-within:border-primary-500 transition">
          <div class="flex-1">
            <textarea id="userInput" rows="1" class="w-full bg-dark-700 text-gray-100 rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-primary-500 resize-none text-base" placeholder="Type your message..."></textarea>
          </div>
          <div class="flex flex-col gap-2 mt-1">
            <button id="sendBtn" class="bg-primary-500 hover:bg-primary-600 text-white p-3 rounded-lg transition">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"></path>
              </svg>
            </button>
            <label for="fileInput" class="bg-dark-500 hover:bg-dark-400 text-gray-300 p-2 rounded-lg cursor-pointer transition">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"></path>
              </svg>
            </label>
            <button id="webSearchBtn" class="bg-dark-500 hover:bg-dark-400 text-gray-300 p-2 rounded-lg transition">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
              </svg>
            </button>
          </div>
        </div>
        <input type="file" id="fileInput" class="hidden" multiple>
        <div id="attachedFiles" class="mt-3 flex flex-wrap gap-3 hidden"></div>
      </div>
    </div>
  </div>

  <!-- Status Notification -->
  <div id="statusNotification" class="fixed bottom-4 right-4 bg-dark-600 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-50"></div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
    <div class="bg-dark-700 rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
      <div class="p-5 border-b border-dark-600 flex justify-between items-center">
        <h2 class="text-xl font-semibold">Settings</h2>
        <button id="closeModalX" class="text-gray-400 hover:text-white">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      
      <div class="p-5">
        <!-- Tab Navigation -->
        <div class="bg-dark-600 rounded-lg p-1 flex mb-5">
          <button class="tab-btn flex-1 py-2 px-4 rounded-md text-gray-400 transition" data-tab="reasoningTab">Reasoning</button>
          <button class="tab-btn flex-1 py-2 px-4 rounded-md text-white bg-primary-500" data-tab="parametersTab">Parameters</button>
          <button class="tab-btn flex-1 py-2 px-4 rounded-md text-gray-400 transition" data-tab="toolsTab">Tools</button>
        </div>
        
        <!-- Reasoning Tab Content -->
        <div id="reasoningTab" class="tab-content hidden">
          <h3 class="text-lg font-medium mb-4 pb-2 border-b border-dark-600">Reasoning Method</h3>
          
          <div class="bg-dark-600 border border-dark-500 rounded-lg p-4 mb-5">
            <div class="space-y-3">
              <div class="flex items-start">
                <input type="radio" id="standardReasoning" name="reasoningMethod" value="standard" class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="standardReasoning" class="ml-3 block text-sm font-medium text-white">
                  Standard (No special prompt)
                  <div class="text-gray-400 text-xs mt-1">Default model behavior with no special reasoning instructions.</div>
                </label>
              </div>
              
              <div class="flex items-start">
                <input type="radio" id="cotReasoning" name="reasoningMethod" value="cot" class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="cotReasoning" class="ml-3 block text-sm font-medium text-white">
                  Chain of Thought (CoT)
                  <div class="text-gray-400 text-xs mt-1">Instructs the model to think step-by-step to solve problems. Improves reasoning but uses more tokens.</div>
                </label>
              </div>
              
              <div class="flex items-start">
                <input type="radio" id="codReasoning" name="reasoningMethod" value="cod" checked class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="codReasoning" class="ml-3 block text-sm font-medium text-white">
                  Chain of Draft (CoD)
                  <div class="text-gray-400 text-xs mt-1">Uses minimal words per step to reduce token usage while maintaining reasoning quality.</div>
                </label>
              </div>
            </div>
          </div>
          
          <!-- COD Word Limit options -->
          <div id="codOptions" class="mb-5">
            <h4 class="text-sm font-medium text-gray-300 mb-2">Word limit per step:</h4>
            <div class="space-y-2">
              <div class="cod-word-limit-option bg-dark-600 border border-primary-500 rounded-lg p-3 cursor-pointer" data-value="5">
                <div class="flex justify-between items-center">
                  <span class="font-medium">5 words</span>
                  <span class="bg-primary-500/20 text-primary-300 text-xs px-2 py-1 rounded-full">Paper Standard</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Original paper recommendation</p>
              </div>
              
              <div class="cod-word-limit-option bg-dark-600 border border-dark-500 hover:border-primary-400 rounded-lg p-3 cursor-pointer" data-value="10">
                <div class="flex justify-between items-center">
                  <span class="font-medium">10 words</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Balanced brevity and clarity</p>
              </div>
              
              <div class="cod-word-limit-option bg-dark-600 border border-dark-500 hover:border-primary-400 rounded-lg p-3 cursor-pointer" data-value="15">
                <div class="flex justify-between items-center">
                  <span class="font-medium">15 words</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">More descriptive steps</p>
              </div>
            </div>
          </div>
          
          <!-- Self-Reflection Options -->
          <div class="flex justify-between items-center mb-4 pb-2 border-b border-dark-600">
            <h3 class="text-lg font-medium">Self-Reflection for Chain of Draft</h3>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="selfReflectionToggle" class="sr-only peer" checked>
              <div class="w-11 h-6 bg-dark-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"></div>
            </label>
          </div>
          
          <div id="selfReflectionInfo" class="bg-dark-600 border border-dark-500 rounded-lg p-4 mb-5">
            <p class="text-gray-400 text-sm mb-3">
              Adds a reflection step after reasoning to help the model verify its own work and catch mistakes.
            </p>
            
            <div class="bg-dark-700 rounded-lg p-4">
              <div class="flex items-center text-purple-300 text-sm font-medium mb-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                How Self-Reflection Works
              </div>
              <div class="text-gray-400 text-xs">
                When using Chain of Draft with self-reflection:
                <ul class="list-disc list-inside mt-2 space-y-1">
                  <li>The model reasons step-by-step as usual</li>
                  <li>Before concluding, it adds a reflection step to check for errors</li>
                  <li>This helps identify calculation mistakes, misunderstandings, or logic errors</li>
                  <li>The reflection is highlighted in the UI for easy identification</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Parameters Tab Content -->
        <div id="parametersTab" class="tab-content">
          <h3 class="text-lg font-medium mb-4 pb-2 border-b border-dark-600">Generation Parameters</h3>
          
          <!-- Streaming Toggle -->
          <div class="flex items-center justify-between mb-5 bg-dark-600 rounded-lg p-3 border border-dark-500">
            <label for="streamingToggle" class="flex items-center cursor-pointer">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-3 text-primary-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
              <div>
                <div class="font-medium text-sm">Enable Streaming Responses</div>
                <div class="text-gray-400 text-xs mt-0.5">See responses appear in real-time as they're generated</div>
              </div>
            </label>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="streamingToggle" class="sr-only peer" checked>
              <div class="w-11 h-6 bg-dark-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"></div>
            </label>
          </div>
          
          <!-- Web Search Toggle -->
          <div class="flex items-center justify-between mb-5 bg-dark-600 rounded-lg p-3 border border-dark-500">
            <label for="webSearchToggle" class="flex items-center cursor-pointer">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-3 text-primary-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
              </svg>
              <div>
                <div class="font-medium text-sm">Enable Web Search</div>
                <div class="text-gray-400 text-xs mt-0.5">Allow model to search the web for up-to-date information</div>
              </div>
            </label>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="webSearchToggle" class="sr-only peer">
              <div class="w-11 h-6 bg-dark-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"></div>
            </label>
          </div>
          
          <!-- Temperature -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="temp" class="block text-sm font-medium text-gray-300">Temperature</label>
              <span id="tempValue" class="text-sm text-gray-400">0.7</span>
            </div>
            <input type="range" id="temp" min="0" max="1" step="0.01" value="0.7" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Controls randomness: lower values make responses more focused.</p>
          </div>
          
          <!-- Top P -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="topP" class="block text-sm font-medium text-gray-300">Top P</label>
              <span id="topPValue" class="text-sm text-gray-400">1</span>
            </div>
            <input type="range" id="topP" min="0" max="1" step="0.01" value="1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Controls diversity via nucleus sampling.</p>
          </div>
          
          <!-- Presence Penalty -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="presencePenalty" class="block text-sm font-medium text-gray-300">Presence Penalty</label>
              <span id="presencePenaltyValue" class="text-sm text-gray-400">0</span>
            </div>
            <input type="range" id="presencePenalty" min="-2" max="2" step="0.01" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Reduces repetition of similar tokens.</p>
          </div>
          
          <!-- Frequency Penalty -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="frequencyPenalty" class="block text-sm font-medium text-gray-300">Frequency Penalty</label>
              <span id="frequencyPenaltyValue" class="text-sm text-gray-400">0</span>
            </div>
            <input type="range" id="frequencyPenalty" min="-2" max="2" step="0.01" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Reduces repetition based on frequency.</p>
          </div>
          
          <!-- Max Tokens -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="maxTokens" class="block text-sm font-medium text-gray-300">Max Tokens</label>
              <span id="maxTokensValue" class="text-sm text-gray-400">4096</span>
            </div>
            <input type="range" id="maxTokens" min="1" max="4096" step="128" value="4096" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Maximum length of the response.</p>
          </div>
        </div>
        
        <!-- Tools Tab Content -->
        <div id="toolsTab" class="tab-content hidden">
          <h3 class="text-lg font-medium mb-4 pb-2 border-b border-dark-600">Available Tools</h3>
          
          <div class="space-y-4">
            <!-- Web Search Tool -->
            <div class="bg-dark-600 border border-dark-500 rounded-lg p-4">
              <div class="flex items-start">
                <input type="checkbox" id="webSearchTool" name="tools" value="web_search" checked class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="webSearchTool" class="ml-3 block text-sm font-medium text-white">
                  Web Search
                  <div class="text-gray-400 text-xs mt-1">Enables the model to search the web for up-to-date information</div>
                </label>
              </div>
            </div>
            
            <!-- Calculator Tool -->
            <div class="bg-dark-600 border border-dark-500 rounded-lg p-4">
              <div class="flex items-start">
                <input type="checkbox" id="calculatorTool" name="tools" value="calculator" checked class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="calculatorTool" class="ml-3 block text-sm font-medium text-white">
                  Calculator
                  <div class="text-gray-400 text-xs mt-1">Allows the model to perform precise mathematical calculations</div>
                </label>
              </div>
            </div>
            
            <!-- Weather Tool -->
            <div class="bg-dark-600 border border-dark-500 rounded-lg p-4">
              <div class="flex items-start">
                <input type="checkbox" id="weatherTool" name="tools" value="weather" class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="weatherTool" class="ml-3 block text-sm font-medium text-white">
                  Weather Information
                  <div class="text-gray-400 text-xs mt-1">Enables the model to retrieve current weather information</div>
                </label>
              </div>
            </div>
            
            <div class="bg-dark-700 rounded-lg p-4 mt-6">
              <div class="flex items-center text-blue-300 text-sm font-medium mb-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                About OpenAI Tools
              </div>
              <div class="text-gray-400 text-xs">
                <p>OpenAI tools extend GPT-4.1's capabilities by allowing it to:</p>
                <ul class="list-disc list-inside mt-2 space-y-1">
                  <li>Access real-time information from the web</li>
                  <li>Perform precise calculations</li>
                  <li>Use external systems to retrieve data</li>
                </ul>
                <p class="mt-2">Select which tools you want to make available to the model in your conversations.</p>
              </div>
            </div>
          </div>
        </div>
        
        <div class="flex justify-end gap-3 pt-4 mt-4 border-t border-dark-600">
          <button id="closeSettings" class="px-4 py-2 bg-dark-600 hover:bg-dark-500 text-gray-300 rounded-lg transition">
            Cancel
          </button>
          <button id="saveSettings" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg transition">
            Save Settings
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * Global Configuration
     ***********************/
    // Define prompts for different reasoning methods
    let PROMPTS = {
      standard: "",
      
      cot: `Think step by step to solve this problem. Explain your reasoning at each step, then provide your final answer.`,
      
      cod: `Think step by step, but produce only minimal notes for each step (5 words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.

Examples:
Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?
A: 20 initial. 12 remaining. 20 - 12 = 8. #### 8 lollipops

Q: Roger has $125. He spends $55 on a video game and then receives $25 for his birthday. How much money does Roger have now?
A: Start: $125. Spent: $55. 125 - 55 = $70. Received: $25. 70 + 25 = $95. #### $95

Q: A square has a perimeter of 20 cm. What is its area?
A: Perimeter = 20 cm. Side length = 20/4 = 5 cm. Area = 5¬≤ = 25 cm¬≤. #### 25 square centimeters

Q: If a fabric store received 45 yards of cotton material and used 2/9 of it for a bulk order, how many yards of cotton material does the fabric store have left?
A: Total: 45 yards. Used: 2/9 √ó 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards`
    };

    // Reasoning Method
    let REASONING_METHOD = "cod"; // Options: "standard", "cot", "cod"
    
    // COD Word Limit
    let COD_WORD_LIMIT = 5;
    
    // Self-reflection
    let SELF_REFLECTION_ENABLED = true;
    
    // Default generation parameters
    let TEMPERATURE = 0.7;
    let TOP_P = 1;
    let MAX_TOKENS = 4096;
    let PRESENCE_PENALTY = 0;
    let FREQUENCY_PENALTY = 0;
    
    // Add streaming flag
    let ENABLE_STREAMING = true;
    
    // Tools configuration
    let ENABLED_TOOLS = ["web_search", "calculator"];
    
    // Web search toggle
    let enableWebSearch = false;
    
    /***********************
     * Thread Management
     ***********************/
    let threads = [];
    let currentThreadId = null;
    let threadCounter = 1;
    
    function createNewThread() {
      const newThread = {
        id: Date.now(),
        name: `Thread ${threadCounter++}`,
        messages: []
      };
      threads.push(newThread);
      currentThreadId = newThread.id;
      updateThreadList();
      renderCurrentThreadMessages();
      
      showNotification("New thread created");
    }
    
    function updateThreadList() {
      // Update main thread list
      const threadList = document.getElementById("threadList");
      if (threadList) {
        threadList.innerHTML = "";
        threads.forEach(thread => {
          const li = document.createElement("li");
          li.textContent = thread.name;
          li.className = "px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition";
          
          if (thread.id === currentThreadId) {
            li.classList.add("bg-dark-600", "text-primary-300");
          } else {
            li.classList.add("text-gray-300");
          }
          
          li.addEventListener("click", () => {
            currentThreadId = thread.id;
            renderCurrentThreadMessages();
            updateThreadList();
          });
          
          threadList.appendChild(li);
        });
      }
      
      // Update mobile thread list
      const mobileThreadList = document.getElementById("mobileThreadList");
      if (mobileThreadList) {
        mobileThreadList.innerHTML = "";
        threads.forEach(thread => {
          const li = document.createElement("li");
          li.textContent = thread.name;
          li.className = "px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition";
          
          if (thread.id === currentThreadId) {
            li.classList.add("bg-dark-600", "text-primary-300");
          } else {
            li.classList.add("text-gray-300");
          }
          
          li.addEventListener("click", () => {
            currentThreadId = thread.id;
            renderCurrentThreadMessages();
            updateThreadList();
            // Close mobile sidebar
            document.getElementById("mobileSidebar").classList.remove("translate-x-0");
            document.getElementById("mobileSidebar").classList.add("-translate-x-full");
          });
          
          mobileThreadList.appendChild(li);
        });
      }
    }
    
    function deleteCurrentThread() {
      if (!currentThreadId) return;
      if (confirm("Are you sure you want to delete this thread?")) {
        threads = threads.filter(thread => thread.id !== currentThreadId);
        if (threads.length > 0) {
          currentThreadId = threads[0].id;
        } else {
          createNewThread();
          return;
        }
        updateThreadList();
        renderCurrentThreadMessages();
        showNotification("Thread deleted");
      }
    }
    
    /***********************
     * Download Functions
     ***********************/
    function downloadCurrentThreadAsTxt() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) {
        showNotification("Error: No active thread found");
        return;
      }
      
      let content = `GPT-4.1 Reasoning Studio - ${REASONING_METHOD.toUpperCase()}`;
      if (REASONING_METHOD === "cod") {
        content += `-${COD_WORD_LIMIT}`;
      }
      content += `\n\n`;
      
      thread.messages.forEach(msg => {
        if (msg.isPlaceholder) return;
        
        const prefix = msg.sender.toUpperCase();
        content += `${prefix}:\n${msg.content}\n\n`;
      });
      
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${thread.name || "Thread"}.txt`;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      showNotification("TXT file downloaded");
    }
    
    /***********************
     * Notification System
     ***********************/
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById("statusNotification");
      notification.textContent = message;
      notification.classList.add("opacity-100");
      
      setTimeout(() => {
        notification.classList.remove("opacity-100");
      }, duration);
    }
    
    /***********************
     * File Upload Management
     ***********************/
    let attachedFiles = [];
    
    function handleFileInput() {
      const fileInput = document.getElementById('fileInput');
      const attachedFilesContainer = document.getElementById('attachedFiles');
      
      if (!fileInput || !attachedFilesContainer) return;
      
      fileInput.addEventListener('change', (event) => {
        try {
          const files = event.target.files;
          const maxFileSize = 10 * 1024 * 1024; // 10MB limit
          
          if (files.length > 0) {
            // Show the container if it was hidden
            attachedFilesContainer.classList.remove('hidden');
            
            // Process each file
            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              
              // Check file size
              if (file.size > maxFileSize) {
                showNotification(`File ${file.name} is too large. Maximum size is 10MB`);
                continue;
              }
              
              // Check if the file is already in the list
              const isDuplicate = attachedFiles.some(f => f.name === file.name && f.size === file.size);
              if (isDuplicate) {
                showNotification(`File ${file.name} is already attached`);
                continue;
              }
              
              // Add file to attachedFiles array
              attachedFiles.push(file);
              
              // Create file preview
              createFilePreview(file, attachedFilesContainer);
            }
            
            // Reset the file input
            fileInput.value = '';
          }
        } catch (error) {
          console.error('Error handling file upload:', error);
          showNotification('Error uploading file. Please try again.');
        }
      });
    }
    
    function createFilePreview(file, container) {
      const filePreview = document.createElement('div');
      filePreview.className = 'relative bg-dark-700 rounded-lg p-2 border border-dark-600';
      
      // Create preview content based on file type
      if (file.type.startsWith('image/')) {
        // Create image preview for image files
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = document.createElement('img');
          img.className = 'w-16 h-16 object-cover rounded';
          img.src = e.target.result;
          filePreview.appendChild(img);
          
          // Add file name
          const fileName = document.createElement('div');
          fileName.className = 'mt-1 text-xs text-gray-400 text-center truncate w-16';
          fileName.textContent = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
          filePreview.appendChild(fileName);
        };
        reader.readAsDataURL(file);
      } else {
        // Create icon preview for non-image files
        const icon = document.createElement('div');
        icon.className = 'w-16 h-16 flex items-center justify-center bg-dark-600 rounded text-2xl';
        icon.textContent = getFileIcon(file.type);
        filePreview.appendChild(icon);
        
        // Add file name
        const fileName = document.createElement('div');
        fileName.className = 'mt-1 text-xs text-gray-400 text-center truncate w-16';
        fileName.textContent = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
        filePreview.appendChild(fileName);
      }
      
      // Add remove button
      const removeButton = document.createElement('button');
      removeButton.className = 'absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs';
      removeButton.textContent = '√ó';
      removeButton.addEventListener('click', () => {
        // Remove from array
        attachedFiles = attachedFiles.filter(f => f !== file);
        
        // Remove from DOM
        filePreview.remove();
        
        // Hide container if no files left
        if (attachedFiles.length === 0) {
          container.classList.add('hidden');
        }
      });
      filePreview.appendChild(removeButton);
      
      // Add the preview to the container
      container.appendChild(filePreview);
    }
    
    function getFileIcon(fileType) {
      if (fileType.startsWith('image/')) {
        return 'üñºÔ∏è';
      } else if (fileType.startsWith('text/')) {
        return 'üìÑ';
      } else if (fileType.includes('pdf')) {
        return 'üìë';
      } else if (fileType.includes('word') || fileType.includes('document')) {
        return 'üìù';
      } else if (fileType.includes('excel') || fileType.includes('spreadsheet')) {
        return 'üìä';
      } else if (fileType.includes('audio')) {
        return 'üéµ';
      } else if (fileType.includes('video')) {
        return 'üé¨';
      } else {
        return 'üì¶';
      }
    }
    
    /***********************
     * Word Counting Utility
     ***********************/
    function countWords(text) {
      // Remove code blocks for more accurate word count
      const textWithoutCode = text.replace(/```[\s\S]*?```/g, '');
      
      // Count mathematical expressions as single words
      let processedText = textWithoutCode
        // Replace simple equations with single tokens
        .replace(/\b\w+\s*=\s*[\d\w+\-*/()]+/g, "EQUATION")
        // Replace fractions with single tokens
        .replace(/\b\d+\/\d+\b/g, "FRACTION")
        // Replace mathematical operations with spaces
        .replace(/[+\-*/=<>]+/g, " ");
      
      // Split by whitespace and filter out empty strings
      const words = processedText.split(/\s+/).filter(word => word.length > 0);
      return words.length;
    }
    
    /***********************
     * Process Bot Messages for Reasoning
     ***********************/
    function processBotMessage(content, reasoningMethod) {
      // For Chain of Draft (CoD) mode
      if (reasoningMethod === "cod") {
        const separatorIndex = content.indexOf("####");
        
        if (separatorIndex !== -1) {
          // Extract thinking steps and final answer
          let thinking = content.substring(0, separatorIndex).trim();
          let answer = content.substring(separatorIndex + 4).trim();
          
          // Check for reflection step
          const reflectionPatterns = [
            /reflection:/i,
            /reflecting:/i,
            /let's verify:/i,
            /verifying:/i,
            /checking work:/i,
            /self-check:/i
          ];
          
          let reflectionIndex = -1;
          let reflectionMatch = null;
          
          // Find the last occurring reflection step
          for (const pattern of reflectionPatterns) {
            const match = thinking.match(pattern);
            if (match && match.index > reflectionIndex) {
              reflectionIndex = match.index;
              reflectionMatch = match;
            }
          }
          
          if (reflectionIndex !== -1) {
            // Split the thinking into regular steps and reflection
            const regularSteps = thinking.substring(0, reflectionIndex).trim();
            const reflectionStep = thinking.substring(reflectionIndex).trim();
            
            // Format reflection step with special styling
            thinking = regularSteps + "\n\n" + reflectionStep;
          }
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer),
            hasReflection: reflectionIndex !== -1
          };
        }
      }
      
      // For Chain of Thought (CoT) mode
      if (reasoningMethod === "cot") {
        // Look for potential conclusion markers
        const conclusionMarkers = [
          "Therefore", "In conclusion", "So,", "Thus,", "Hence,", 
          "The answer is", "To conclude", "Finally,", "In summary"
        ];
        
        // Add a marker for just "Answer:" or "Final answer:" on its own line
        const answerMarkers = [
          /\n(Answer:|Final answer:)/i,
          /^(Answer:|Final answer:)/i,
          /\n(The answer is:|My answer is:|Final answer is:)/i
        ];
        
        // Try each answer marker pattern
        for (const pattern of answerMarkers) {
          const answerMatch = content.match(pattern);
          if (answerMatch && answerMatch.index !== undefined) {
            // Found a marker
            const thinking = content.substring(0, answerMatch.index).trim();
            const answer = content.substring(answerMatch.index + answerMatch[0].length).trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: answer,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(answer)
            };
          }
        }
        
        // If no explicit answer marker, look for conclusion indicator words
        let lastMarkerIndex = -1;
        let bestMarker = "";
        
        for (const marker of conclusionMarkers) {
          // Check for the marker near the end of the text (last 40%)
          const startSearchPos = content.length * 0.6;
          const markerIndex = content.indexOf(marker, startSearchPos);
          
          if (markerIndex > lastMarkerIndex && markerIndex !== -1) {
            lastMarkerIndex = markerIndex;
            bestMarker = marker;
          }
        }
        
        // If we found a conclusion marker in a reasonable position
        if (lastMarkerIndex > content.length * 0.6) {
          const thinking = content.substring(0, lastMarkerIndex).trim();
          const answer = content.substring(lastMarkerIndex).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer)
          };
        }
      }
      
      // For standard reasoning
      if (reasoningMethod === "standard") {
        return {
          content: content,
          thinking: null, 
          answer: content,
          thinkingWordCount: 0,
          answerWordCount: countWords(content)
        };
      }
      
      // Default: if unable to separate, return entire content
      return {
        content: content,
        thinking: reasoningMethod === "cot" || reasoningMethod === "cod" ? content : null,
        answer: reasoningMethod === "standard" ? content : null,
        thinkingWordCount: reasoningMethod === "cot" || reasoningMethod === "cod" ? countWords(content) : 0,
        answerWordCount: reasoningMethod === "standard" ? countWords(content) : 0
      };
    }
    
    /***********************
     * Format Thinking Steps for Reasoning
     ***********************/
    function formatThinkingSteps(thinking, reasoningMethod) {
      if (!thinking) return '';
      
      // Remove any "###" prefixes
      let cleanedThinking = thinking.replace(/^#{1,3}\s*/gm, '');
      
      if (reasoningMethod === "cod") {
        // Split by periods to separate steps, but preserve periods within numbers
        let steps = cleanedThinking.split(/\.(?!\d)/).filter(step => step.trim().length > 0);
        
        // Create formatted steps including reflection handling
        return steps.map((step, index) => {
          // Check if this is a reflection step
          const isReflection = /reflection:|reflecting:|let's verify:|verifying:|checking work:|self-check:/i.test(step);
          
          const stepClass = isReflection ? 
            'flex items-start p-3 mb-2 rounded-lg bg-indigo-900/20 border-l-4 border-indigo-500' : 
            'flex items-start p-3 mb-2 rounded-lg bg-slate-800/30';
          
          let stepContent = step.trim();
          // Add period back if it's not a reflection step
          if (!isReflection && !stepContent.endsWith('.')) {
            stepContent += '.';
          }
          
          // For reflection steps, add an icon and style differently
          if (isReflection) {
            return `<div class="${stepClass} reflection-step">
              <span class="flex items-center justify-center min-w-8 h-8 mr-3 rounded-full bg-indigo-700/50 text-indigo-300 text-sm font-bold step-number">üîç</span>
              <span class="step-content font-mono text-sm text-indigo-300">${stepContent}</span>
            </div>`;
          }
          
          return `<div class="${stepClass}">
            <span class="flex items-center justify-center min-w-8 h-8 mr-3 rounded-full bg-slate-700 text-primary-400 text-sm font-bold step-number">${index + 1}</span>
            <span class="step-content font-mono text-sm">${stepContent}</span>
          </div>`;
        }).join('');
      } else {
        // Original formatting for CoT
        let steps = cleanedThinking.split(/\.\s+/);
        return steps.filter(step => step.trim())
          .map(step => 
            `<div class="p-2 mb-2 border-l-2 border-slate-600">${step.trim()}${!step.endsWith('.') ? '.' : ''}</div>`
          ).join('');
      }
    }
    
    /***********************
     * Transform Message
     ***********************/
    function transformMessage(content) {
      if (!content) return '';
      
      // Remove "###" prefixes from lines
      let processedContent = content.replace(/^#{1,3}\s*/gm, '');
      
      // Process markdown with marked.js if available
      if (typeof marked !== 'undefined') {
        return marked.parse(processedContent);
      } else {
        // Simple markdown-like transformation for code blocks if marked is not available
        const transformed = processedContent.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
          let language = '';
          const lines = codeContent.split('\n');
          if (lines.length > 0 && !lines[0].includes(' ')) {
            language = lines[0].trim();
            lines.shift();
          }
          return `<pre><code class="${language}">${lines.join('\n')}</code></pre>`;
        });
        
        return transformed;
      }
    }
    
    /***********************
     * Rendering Messages
     ***********************/
    function renderCurrentThreadMessages() {
      const chatMessagesDiv = document.getElementById("chatMessages");
      if (!chatMessagesDiv) return;
      
      chatMessagesDiv.innerHTML = "";
      const thread = threads.find(t => t.id === currentThreadId);
      
      if (thread) {
        thread.messages.forEach(msg => {
          // Create message container
          const messageDiv = document.createElement("div");
          
          // Apply different styling based on sender
          if (msg.sender === "user") {
            messageDiv.className = "flex justify-end";
            
            const msgContent = document.createElement("div");
            msgContent.className = "max-w-[90%] bg-primary-600 text-white p-4 rounded-2xl rounded-tr-sm shadow-md";
            
            // Format and set content
            msgContent.innerHTML = transformMessage(msg.content);
            
            // Add files to user messages if present
            if (msg.files && msg.files.length > 0) {
              addFilesToMessage(msgContent, msg.files);
            }
            
            messageDiv.appendChild(msgContent);
          } else {
            // Bot message
            messageDiv.className = "flex justify-start";
            
            const msgContent = document.createElement("div");
            msgContent.className = "max-w-[90%] bg-dark-700 border border-dark-500 p-4 rounded-2xl rounded-tl-sm shadow-md";
            
            // Handle placeholder messages
            if (msg.isPlaceholder) {
              msgContent.classList.add("opacity-70");
              msgContent.innerHTML = `<div class="flex items-center gap-2">
                <svg class="animate-spin h-4 w-4 text-primary-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                ${msg.content}
              </div>`;
            } 
            // Handle streaming messages
            else if (msg.isStreaming) {
              msgContent.classList.add("streaming");
              msgContent.innerHTML = transformMessage(msg.content);
              msgContent.innerHTML += `<div class="text-primary-400 text-xs mt-2 streaming-indicator">Generating</div>`;
            } 
            // Handle thinking/answer messages
            else if (msg.thinking) {
              // Thinking steps
              const thinkingContainer = document.createElement("div");
              thinkingContainer.className = "thinking-steps bg-dark-800 rounded-lg p-4 mb-4 border border-dark-600";
              
              // Add label for thinking steps
              const thinkingLabel = document.createElement("div");
              thinkingLabel.className = "text-xs uppercase tracking-wider font-semibold text-gray-400 mb-3 pb-2 border-b border-dark-500";
              thinkingLabel.textContent = msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") ? 
                "Chain of Draft Steps" : "Thinking Steps";
              thinkingContainer.appendChild(thinkingLabel);
              
              // Format thinking steps
              const thinkingContent = document.createElement("div");
              thinkingContent.innerHTML = formatThinkingSteps(
                msg.thinking, 
                msg.reasoningMethod ? msg.reasoningMethod.toLowerCase() : REASONING_METHOD
              );
              thinkingContainer.appendChild(thinkingContent);
              
              msgContent.appendChild(thinkingContainer);
              
              // Final answer
              if (msg.answer) {
                const answerDiv = document.createElement("div");
                answerDiv.className = "bg-dark-800 rounded-lg p-4 border border-dark-600";
                
                const answerLabel = document.createElement("div");
                answerLabel.className = "text-xs uppercase tracking-wider font-semibold text-primary-400 mb-3 pb-2 border-b border-dark-500";
                answerLabel.textContent = "Final Answer";
                answerDiv.appendChild(answerLabel);
                
                const answerContent = document.createElement("div");
                answerContent.innerHTML = transformMessage(msg.answer);
                answerDiv.appendChild(answerContent);
                
                msgContent.appendChild(answerDiv);
              }
            } 
            // Default content display
            else {
              msgContent.innerHTML = transformMessage(msg.content);
            }
            
            // Add word count badge for bot messages (except placeholders)
            if (!msg.isPlaceholder && msg.wordCount !== undefined) {
              const wordCountBadge = document.createElement("div");
              wordCountBadge.className = "absolute -top-1 -right-1 bg-dark-800 text-xs px-2 py-1 rounded-full border border-dark-600 shadow-md";
              
              // Display reasoning method and word count
              let badgeText = `${msg.wordCount} words`;
              
              if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
                badgeText = `<span class="text-gray-400">${msg.thinkingWordCount}</span> + <span class="text-primary-400">${msg.answerWordCount}</span>`;
              }
              
              wordCountBadge.innerHTML = badgeText;
              
              // Make the container relative for absolute positioning
              msgContent.style.position = "relative";
              msgContent.appendChild(wordCountBadge);
            }
            
            // Add tool usage indicator if present
            if (msg.tool_calls && msg.tool_calls.length > 0) {
              const toolBadge = document.createElement("div");
              toolBadge.className = "mt-2 px-2 py-1 bg-blue-900/20 border border-blue-800/30 rounded text-xs text-blue-400";
              
              let toolNames = msg.tool_calls.map(tool => {
                if (tool.type === "web_search") return "Web Search";
                if (tool.type === "function" && tool.function) return tool.function.name;
                return "Tool";
              }).join(", ");
              
              toolBadge.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
              </svg> Used: ${toolNames}`;
              
              msgContent.appendChild(toolBadge);
            }
            
            // Add the content to the message div
            messageDiv.appendChild(msgContent);
          }
          
          chatMessagesDiv.appendChild(messageDiv);
        });
        
        // Scroll to the bottom
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
      }
      
      // Add syntax highlighting to code blocks
      if (typeof hljs !== 'undefined') {
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      }
      
      // Add copy buttons to code blocks
      addCodeCopyButtons();
    }
    
    function addMessageToCurrentThread(content, sender, isPlaceholder = false, files = []) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        // Process bot messages to separate thinking from answer
        let thinking = null;
        let answer = null;
        let thinkingWordCount = 0;
        let answerWordCount = 0;
        let totalWordCount = 0;
        
        if (sender === "bot" && !isPlaceholder) {
          const processed = processBotMessage(content, REASONING_METHOD);
          thinking = processed.thinking;
          answer = processed.answer;
          thinkingWordCount = processed.thinkingWordCount || 0;
          answerWordCount = processed.answerWordCount || 0;
          totalWordCount = thinkingWordCount + answerWordCount;
        }
        
        thread.messages.push({
          content,
          sender,
          isPlaceholder,
          timestamp: new Date(),
          wordCount: sender === "bot" && !isPlaceholder ? totalWordCount : undefined,
          reasoningMethod: sender === "bot" && !isPlaceholder ? 
            (REASONING_METHOD === "cod" ? `${REASONING_METHOD.toUpperCase()}-${COD_WORD_LIMIT}` : REASONING_METHOD.toUpperCase()) : 
            undefined,
          thinking,
          answer,
          thinkingWordCount: sender === "bot" && !isPlaceholder ? thinkingWordCount : undefined,
          answerWordCount: sender === "bot" && !isPlaceholder ? answerWordCount : undefined,
          // Add files to the message
          files: files && files.length > 0 ? files : undefined
        });
        
        renderCurrentThreadMessages();
      }
    }
    
    /***********************
     * Build Messages Array for Chat Completions
     ***********************/
    function buildMessagesForChat() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return [];
      
      const messages = [];
      
      // If we have a reasoning method other than standard, add the system prompt
      if (REASONING_METHOD !== "standard") {
        // Use the selected reasoning method prompt
        let systemPrompt = PROMPTS[REASONING_METHOD];
        
        // If it's COD, update the word limit
        if (REASONING_METHOD === "cod") {
          // First update the word limit
          systemPrompt = systemPrompt.replace(/\(\d+ words maximum per step\)/, `(${COD_WORD_LIMIT} words maximum per step)`);
          
          // If self-reflection is enabled but not in the prompt, add it
          if (SELF_REFLECTION_ENABLED && !systemPrompt.includes("add a reflection step")) {
            const reflectionInstruction = "\n\nBefore providing your final answer, add a reflection step starting with \"Reflection:\" to verify your work and catch any potential errors.";
            // Find a good place to insert - after the first paragraph but before examples
            const firstParagraphEnd = systemPrompt.indexOf("\n\n");
            if (firstParagraphEnd !== -1) {
              const examplesStart = systemPrompt.indexOf("Examples:");
              if (examplesStart !== -1 && examplesStart > firstParagraphEnd) {
                systemPrompt = systemPrompt.substring(0, examplesStart) + reflectionInstruction + "\n\n" + systemPrompt.substring(examplesStart);
              } else {
                systemPrompt = systemPrompt.substring(0, firstParagraphEnd + 2) + reflectionInstruction + systemPrompt.substring(firstParagraphEnd + 2);
              }
            } else {
              systemPrompt += reflectionInstruction;
            }
          }
        }
        
        messages.push({
          role: "system",
          content: systemPrompt
        });
      }
      
      // Add all user and assistant messages
      thread.messages
        .filter(msg => !msg.isPlaceholder)
        .forEach(msg => {
          if (msg.sender === "user" && msg.files && msg.files.length > 0) {
            // Check if we have any image files with dataUrl
            const hasImages = msg.files.some(file => 
              file.type.startsWith('image/') && file.dataUrl);
            
            if (hasImages) {
              // For messages with images, create multimodal message format
              const contentArray = [];
              
              // Add text content if present
              if (msg.content && msg.content.trim()) {
                contentArray.push({ 
                  type: "text", 
                  text: msg.content 
                });
              }
              
              // Add images to the content array
              msg.files.forEach(fileObj => {
                if (fileObj.type.startsWith('image/') && fileObj.dataUrl) {
                  contentArray.push({
                    type: "image_url",
                    image_url: {
                      url: fileObj.dataUrl
                    }
                  });
                }
              });
              
              // Add the multimodal message
              messages.push({
                role: "user",
                content: contentArray
              });
            } else {
              // No valid images, use text-only format
              messages.push({
                role: "user",
                content: msg.content
              });
            }
          } else {
            // Regular text message
            messages.push({
              role: msg.sender === "user" ? "user" : "assistant",
              content: msg.content
            });
          }
        });
      
      return messages;
    }
    
    /***********************
     * Get Tools Configuration
     ***********************/
    function getToolsConfiguration() {
      const tools = [];
      
      // Add web search if enabled
      if (ENABLED_TOOLS.includes("web_search") || enableWebSearch) {
        tools.push({ type: "web_search_preview" });
      }
      
      // Add calculator if enabled
      if (ENABLED_TOOLS.includes("calculator")) {
        tools.push({
          type: "function",
          function: {
            name: "calculate_expression",
            description: "Calculate the result of a mathematical expression",
            parameters: {
              type: "object",
              properties: {
                expression: {
                  type: "string",
                  description: "The mathematical expression to calculate (e.g., '2+2', 'sin(30)', 'sqrt(144)')"
                }
              },
              required: ["expression"]
            }
          }
        });
      }
      
      // Add weather if enabled
      if (ENABLED_TOOLS.includes("weather")) {
        tools.push({
          type: "function",
          function: {
            name: "get_current_weather",
            description: "Get the current weather in a given location",
            parameters: {
              type: "object",
              properties: {
                location: {
                  type: "string",
                  description: "The city and state, e.g. San Francisco, CA"
                },
                unit: {
                  type: "string",
                  enum: ["celsius", "fahrenheit"],
                  description: "The temperature unit to use. Default is celsius."
                }
              },
              required: ["location"]
            }
          }
        });
      }
      
      return tools.length > 0 ? tools : undefined;
    }
    
    /***********************
     * Message Sending
     ***********************/
    
    // Helper function to read files as base64 data URLs
    function readFileAsBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          resolve(reader.result); // This is the data URL
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    async function sendMessage(message) {
      // Get the current streaming setting
      const savedStreamingPref = localStorage.getItem('streamingEnabled');
      ENABLE_STREAMING = savedStreamingPref !== null ? savedStreamingPref === 'true' : ENABLE_STREAMING;
      
      console.log(`Current streaming state: ${ENABLE_STREAMING ? 'enabled' : 'disabled'}`);
      
      // Process files for sending to the API
      let processedFiles = [];
      
      if (attachedFiles.length > 0) {
        try {
          console.log(`Processing ${attachedFiles.length} files for sending`);
          
          for (const file of attachedFiles) {
            // For images, read as data URL
            if (file.type.startsWith('image/')) {
              const dataUrl = await readFileAsBase64(file);
              processedFiles.push({
                originalFile: file,
                name: file.name,
                type: file.type,
                size: file.size,
                dataUrl: dataUrl
              });
              console.log(`Processed image file: ${file.name}`);
            } else {
              // For other files, just add metadata
              processedFiles.push({
                originalFile: file,
                name: file.name,
                type: file.type,
                size: file.size
              });
            }
          }
        } catch (error) {
          console.error('Error processing files:', error);
          showNotification('Error processing files for upload');
        }
      }
      
      // Add message to thread with processed files
      addMessageToCurrentThread(message, "user", false, processedFiles);
      
      // Clear attached files after sending
      attachedFiles = [];
      const attachedFilesContainer = document.getElementById('attachedFiles');
      if (attachedFilesContainer) {
        attachedFilesContainer.innerHTML = '';
        attachedFilesContainer.style.display = 'none';
      }
      
      // Add placeholder message showing we're thinking
      let placeholderText = "Thinking...";
      addMessageToCurrentThread(placeholderText, "bot", true);
      const thread = threads.find(t => t.id === currentThreadId);
      const placeholderIndex = thread.messages.length - 1;
      
      try {
        // Build messages array with current settings
        const messagesForApi = buildMessagesForChat();
        
        // Get tools configuration if enabled
        const tools = getToolsConfiguration();
        
        // Validate max_tokens before sending to API
        let validatedMaxTokens = parseInt(MAX_TOKENS);
        
        // Ensure it's a valid number
        if (isNaN(validatedMaxTokens) || !isFinite(validatedMaxTokens)) {
          validatedMaxTokens = 4096; // Default to 4096 if invalid
          console.warn(`Invalid max_tokens value, defaulting to ${validatedMaxTokens}`);
        }
        
        // Enforce model's limits
        validatedMaxTokens = Math.min(Math.max(1, validatedMaxTokens), 4096);
        if (validatedMaxTokens !== MAX_TOKENS) {
          console.warn(`Adjusted max_tokens from ${MAX_TOKENS} to ${validatedMaxTokens} to meet API requirements`);
        }
        
        // Add timestamp to URL to prevent caching
        const timestamp = new Date().getTime();
        const cacheBuster = `?t=${timestamp}`;
        
        // Create payload for API request
        const payload = {
          messages: messagesForApi,
          temperature: TEMPERATURE,
          top_p: TOP_P,
          max_tokens: validatedMaxTokens,
          presence_penalty: PRESENCE_PENALTY,
          frequency_penalty: FREQUENCY_PENALTY,
          stream: ENABLE_STREAMING // Use the streaming flag
        };
        
        // Add tools if enabled
        if (tools && tools.length > 0) {
          payload.tools = tools;
        }
        
        // Check if we should use streaming
        if (ENABLE_STREAMING) {
          console.log("Using streaming mode");
          
          try {
            // Update the placeholder to indicate streaming
            thread.messages[placeholderIndex].content = "Connecting to streaming API...";
            renderCurrentThreadMessages();
            
            // Prepare to collect the full response
            let fullResponse = "";
            let renderPending = false;
            
            // First send the initial request to start the stream
            const initResponse = await fetch(`/api/streaming${cacheBuster}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            
            if (!initResponse.ok) {
              throw new Error(`Error starting stream: ${initResponse.status}`);
            }
            
            // Set up event source for streaming
            const reader = initResponse.body.getReader();
            const decoder = new TextDecoder();
            
            // Process the stream
            while (true) {
              const { done, value } = await reader.read();
              
              if (done) {
                console.log("Stream complete");
                break;
              }
              
              // Decode this chunk
              const chunk = decoder.decode(value, { stream: true });
              
              // Process SSE format (data: {...}\n\n)
              const lines = chunk.split('\n');
              
              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  // Extract the data part
                  const dataText = line.slice(6).trim();
                  
                  // Special end marker
                  if (dataText === '[DONE]') {
                    console.log("Received [DONE] marker");
                    continue;
                  }
                  
                  try {
                    // Attempt to parse as JSON
                    const data = JSON.parse(dataText);
                    
                    // Check for errors from server
                    if (data.error === true) {
                      console.error("Streaming error:", data.message);
                      throw new Error(data.message || "Unknown streaming error");
                    }
                    
                    // Check for completion
                    if (data.done === true) {
                      console.log("Received done: true");
                      continue;
                    }
                    
                    // Extract new content
                    if (data.choices && data.choices[0]) {
                      // Get the content delta or content
                      const contentDelta = data.choices[0].delta?.content || 
                                          data.choices[0].message?.content || 
                                          "";
                      
                      if (contentDelta) {
                        // Add to full response
                        fullResponse += contentDelta;
                        
                        // Update the message
                        thread.messages[placeholderIndex] = {
                          content: fullResponse,
                          sender: "bot",
                          isPlaceholder: false,
                          timestamp: new Date(),
                          isStreaming: true // Flag as streaming
                        };
                        
                        // Use requestAnimationFrame for smoother rendering
                        if (!renderPending) {
                          renderPending = true;
                          requestAnimationFrame(() => {
                            renderCurrentThreadMessages();
                            renderPending = false;
                          });
                        }
                      }
                      
                      // Check for tool calls
                      if (data.choices[0].delta?.tool_calls) {
                        // Store tool calls on the message
                        if (!thread.messages[placeholderIndex].tool_calls) {
                          thread.messages[placeholderIndex].tool_calls = [];
                        }
                        
                        thread.messages[placeholderIndex].tool_calls.push(
                          ...data.choices[0].delta.tool_calls
                        );
                        
                        if (!renderPending) {
                          renderPending = true;
                          requestAnimationFrame(() => {
                            renderCurrentThreadMessages();
                            renderPending = false;
                          });
                        }
                      }
                    }
                  } catch (parseError) {
                    // If not valid JSON, just log it
                    if (dataText && dataText !== '') {
                      console.log("Non-JSON data received:", dataText);
                    }
                  }
                }
              }
            }
            
            // Stream is complete - process the full response
            console.log("Stream complete, processing final response");
            
            // Create response metadata
            let reasoningInfo = REASONING_METHOD.toUpperCase();
            if (REASONING_METHOD === "cod") {
              reasoningInfo += `-${COD_WORD_LIMIT}`;
            }
            
            // Process bot message to separate thinking and answer parts
            const processed = processBotMessage(fullResponse, REASONING_METHOD);
            
            // Update with the finalized message (not streaming anymore)
            thread.messages[placeholderIndex] = {
              content: fullResponse,
              sender: "bot",
              isPlaceholder: false,
              timestamp: new Date(),
              wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
              reasoningMethod: reasoningInfo,
              thinking: processed.thinking,
              answer: processed.answer,
              thinkingWordCount: processed.thinkingWordCount || 0,
              answerWordCount: processed.answerWordCount || 0,
              isStreaming: false // No longer streaming
            };
            
            renderCurrentThreadMessages();
            
          } catch (streamingError) {
            console.error("Streaming error:", streamingError);
            
            // Fallback to non-streaming if streaming fails
            console.log("Falling back to non-streaming API...");
            thread.messages[placeholderIndex].content = "Streaming failed, falling back to regular API...";
            renderCurrentThreadMessages();
            
            // Set streaming to false in the payload for fallback
            payload.stream = false;
            
            // Continue with non-streaming approach below
            ENABLE_STREAMING = false; // Temporarily disable streaming
          }
        }
        
        // Only proceed with non-streaming approach if streaming is disabled or failed
        if (!ENABLE_STREAMING) {
          // Set a client-side timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 35000); // 35 seconds timeout
          
          console.log("Sending non-streaming request...");
          
          try {
            // Send request to the API proxy
            const response = await fetch(`/api/proxy${cacheBuster}`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(payload),
              signal: controller.signal
            });
            
            // Clear the timeout
            clearTimeout(timeoutId);
            
            // If successful, process the response
            if (response.ok) {
              const data = await response.json();
              const botReply = data.choices &&
                              data.choices[0] &&
                              data.choices[0].message &&
                              data.choices[0].message.content;
              
              if (botReply) {
                const trimmedReply = botReply.trim();
                
                // Create response metadata
                let reasoningInfo = REASONING_METHOD.toUpperCase();
                if (REASONING_METHOD === "cod") {
                  reasoningInfo += `-${COD_WORD_LIMIT}`;
                }
                
                // Process bot message to separate thinking and answer parts
                const processed = processBotMessage(trimmedReply, REASONING_METHOD);
                
                // Store any tool calls that were used
                const toolCalls = data.choices[0].message.tool_calls;
                
                thread.messages[placeholderIndex] = {
                  content: trimmedReply,
                  sender: "bot",
                  isPlaceholder: false,
                  timestamp: new Date(),
                  wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
                  reasoningMethod: reasoningInfo,
                  thinking: processed.thinking,
                  answer: processed.answer,
                  thinkingWordCount: processed.thinkingWordCount || 0,
                  answerWordCount: processed.answerWordCount || 0,
                  tool_calls: toolCalls
                };
                renderCurrentThreadMessages();
                
                // Re-enable streaming for next message
                ENABLE_STREAMING = true;
                
                return;
              }
            } else {
              // Handle error response
              let errorText = "Unknown error";
              try {
                const errorResponse = await response.json();
                errorText = errorResponse.message || errorResponse.error || `Status code: ${response.status}`;
              } catch (e) {
                console.error("Failed to parse error response:", e);
              }
              
              throw new Error(`OpenAI API returned status: ${response.status} - ${errorText}`);
            }
          } catch (fetchError) {
            // Check if this is an abort error (timeout)
            if (fetchError.name === 'AbortError') {
              throw new Error("The API request timed out. Try again with shorter messages or reduce max_tokens in settings.");
            } else {
              throw fetchError;
            }
          }
        }
      } catch (error) {
        console.error("Error:", error);
        
        let errorMessage = "Error: " + error.message;
        
        // Check for specific error types and provide helpful messages
        if (error.name === "AbortError") {
          errorMessage = "Request timed out. Try again with a shorter question or reduce max_tokens in settings.";
        } else if (error.message.includes("401")) {
          errorMessage = "Authentication failed. Please check if your API key is properly set in environment variables.";
        } else if (error.message.includes("429")) {
          errorMessage = "Rate limit exceeded. Please wait a moment before trying again.";
        } else if (error.message.includes("500")) {
          errorMessage = "Server error. Please try again later.";
        } else if (error.message.includes("Failed to fetch")) {
          errorMessage = "Could not connect to the API. Please check your internet connection and try again.";
        }
        
        thread.messages[placeholderIndex] = {
          content: errorMessage,
          sender: "bot",
          isPlaceholder: false,
          timestamp: new Date(),
          wordCount: 0,
          reasoningMethod: REASONING_METHOD.toUpperCase(),
          thinking: null,
          answer: null,
          thinkingWordCount: 0,
          answerWordCount: 0
        };
        
        renderCurrentThreadMessages();
        
        // Re-enable streaming for next message
        ENABLE_STREAMING = true;
      }
    }
    
    /***********************
     * Code Copy Feature
     ***********************/
    function addCodeCopyButtons() {
      const codeBlocks = document.querySelectorAll('pre code');
      codeBlocks.forEach(code => {
        // Skip if already has a copy button container
        if (code.parentElement.classList.contains('relative')) {
          return;
        }
        
        const pre = code.parentElement;
        
        // Create container div
        const container = document.createElement('div');
        container.className = 'relative mb-4 rounded-lg overflow-hidden';
        pre.parentNode.insertBefore(container, pre);
        container.appendChild(pre);
        
        // Add language badge if specified
        const codeClass = code.className;
        const language = codeClass.match(/language-([^\s]+)/)?.[1];
        if (language && language !== 'plaintext') {
          const langBadge = document.createElement('div');
          langBadge.className = 'absolute top-2 left-2 bg-dark-900/80 text-xs py-1 px-2 rounded text-gray-400';
          langBadge.textContent = language;
          container.appendChild(langBadge);
        }
        
        // Add styles to the pre element
        pre.className = 'bg-dark-900 rounded-lg p-4 overflow-x-auto text-sm';
        
        // Add copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'absolute top-2 right-2 bg-dark-900/80 text-gray-400 hover:text-white text-xs py-1 px-2 rounded transition-colors';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', () => {
          navigator.clipboard.writeText(code.textContent || '')
            .then(() => {
              copyBtn.textContent = 'Copied!';
              copyBtn.classList.add('text-green-400');
              setTimeout(() => {
                copyBtn.textContent = 'Copy';
                copyBtn.classList.remove('text-green-400');
              }, 2000);
            })
            .catch(() => {
              copyBtn.textContent = 'Failed';
              copyBtn.classList.add('text-red-400');
              setTimeout(() => {
                copyBtn.textContent = 'Copy';
copyBtn.classList.remove('text-red-400');
              }, 2000);
            });
        });
        
        container.appendChild(copyBtn);
      });
    }
    
    /***********************
     * Web Search Functions
     ***********************/
    function toggleWebSearch() {
      const btn = document.getElementById('webSearchBtn');
      if (!btn) return;
      
      // Toggle the state
      enableWebSearch = !enableWebSearch;
      
      // Store preference
      localStorage.setItem('webSearchEnabled', enableWebSearch.toString());
      
      // Update button appearance with active class
      if (enableWebSearch) {
        btn.classList.add('bg-primary-500', 'text-white');
        btn.classList.remove('bg-dark-500', 'text-gray-300');
        btn.title = "Web search is enabled (click to disable)";
      } else {
        btn.classList.remove('bg-primary-500', 'text-white');
        btn.classList.add('bg-dark-500', 'text-gray-300');
        btn.title = "Web search is disabled (click to enable)";
      }
      
      // Show notification
      showNotification(enableWebSearch ? 'Web search enabled' : 'Web search disabled');
      
      console.log(`Web search ${enableWebSearch ? 'enabled' : 'disabled'}`);
    }
    
    /***********************
     * Settings Management
     ***********************/
    
    // Tab handling
    function setupTabNavigation() {
      try {
        console.log("Setting up tab navigation");
        
        // Get all tab buttons and tab contents
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // Add click event listeners to tab buttons
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            try {
              // Remove active class from all buttons and contents
              tabButtons.forEach(btn => {
                btn.classList.remove('bg-primary-500', 'text-white');
                btn.classList.add('text-gray-400');
              });
              
              tabContents.forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
              });
              
              // Add active class to clicked button
              button.classList.add('bg-primary-500', 'text-white');
              button.classList.remove('text-gray-400');
              
              // Show corresponding tab content
              const tabId = button.getAttribute('data-tab');
              const tabContent = document.getElementById(tabId);
              if (tabContent) {
                tabContent.classList.add('active');
                tabContent.style.display = 'block';
              }
            } catch (err) {
              console.error("Error handling tab click:", err);
            }
          });
        });
      } catch (err) {
        console.error("Error in setupTabNavigation:", err);
      }
    }
    
    // COD options
    function setupCODOptions() {
      const reasoningRadios = document.getElementsByName('reasoningMethod');
      const codOptions = document.getElementById('codOptions');
      
      if (!codOptions) return;
      
      // Initial state
      if (REASONING_METHOD === 'cod') {
        codOptions.style.display = 'block';
        updateCoDOptionsUI();
      } else {
        codOptions.style.display = 'none';
      }
      
      // Update when reasoning method changes
      reasoningRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.value === 'cod' && radio.checked) {
            codOptions.style.display = 'block';
            updateCoDOptionsUI();
          } else {
            codOptions.style.display = 'none';
          }
        });
      });
      
      // Update self-reflection when setting changes
      const selfReflectionToggle = document.getElementById('selfReflectionToggle');
      if (selfReflectionToggle) {
        selfReflectionToggle.addEventListener('change', () => {
          SELF_REFLECTION_ENABLED = selfReflectionToggle.checked;
        });
      }
    }
    
    // Improved Chain of Draft word limit options UI
    function updateCoDOptionsUI() {
      const options = document.querySelectorAll('.cod-word-limit-option');
      if (!options) return;
      
      // Update selected state
      options.forEach(option => {
        const value = parseInt(option.getAttribute('data-value'));
        if (value === COD_WORD_LIMIT) {
          option.classList.add('border-primary-500');
          option.classList.remove('border-dark-500', 'hover:border-primary-400');
        } else {
          option.classList.remove('border-primary-500');
          option.classList.add('border-dark-500', 'hover:border-primary-400');
        }
      });
      
      // Add event listeners to the word limit options
      options.forEach(option => {
        // Remove existing listeners
        const newOption = option.cloneNode(true);
        option.parentNode.replaceChild(newOption, option);
        
        // Add new listener
        newOption.addEventListener('click', () => {
          // Update selected state
          options.forEach(opt => {
            opt.classList.remove('border-primary-500');
            opt.classList.add('border-dark-500', 'hover:border-primary-400');
          });
          newOption.classList.add('border-primary-500');
          newOption.classList.remove('border-dark-500', 'hover:border-primary-400');
          
          // Update word limit value
          COD_WORD_LIMIT = parseInt(newOption.getAttribute('data-value'));
          
          // Update the prompt
          updateCoDPrompt();
        });
      });
    }
    
    // Improved function to update the CoD prompt when word limit changes
    function updateCoDPrompt() {
      // Update the prompt to reflect new word limit
      const basePrompt = `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.`;
      
      // Add self-reflection instruction if enabled
      const basePromptWithReflection = SELF_REFLECTION_ENABLED ? 
        basePrompt + `\n\nBefore providing your final answer, add a reflection step starting with "Reflection:" to verify your work and catch any potential errors.` : 
        basePrompt;
      
      // Keep the examples part of the prompt
      const examplesStart = PROMPTS.cod.indexOf('Examples:');
      if (examplesStart !== -1) {
        PROMPTS.cod = basePromptWithReflection + '\n\n' + PROMPTS.cod.substring(examplesStart);
      } else {
        PROMPTS.cod = basePromptWithReflection;
      }
      
      console.log(`Updated CoD prompt with word limit: ${COD_WORD_LIMIT}, self-reflection: ${SELF_REFLECTION_ENABLED}`);
    }
    
    // Tool options
    function setupToolsOptions() {
      const toolCheckboxes = document.querySelectorAll('input[name="tools"]');
      if (!toolCheckboxes) return;
      
      // Initialize checkboxes based on current settings
      toolCheckboxes.forEach(checkbox => {
        const toolName = checkbox.value;
        checkbox.checked = ENABLED_TOOLS.includes(toolName);
        
        // Add change listener
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            // Add tool if not already in the array
            if (!ENABLED_TOOLS.includes(toolName)) {
              ENABLED_TOOLS.push(toolName);
            }
          } else {
            // Remove tool from array
            ENABLED_TOOLS = ENABLED_TOOLS.filter(tool => tool !== toolName);
          }
          // Save to local storage
          localStorage.setItem('enabledTools', JSON.stringify(ENABLED_TOOLS));
        });
      });
    }
    
    // Settings slider handling
    function setupSliders() {
      // Connect all sliders to their value displays
      document.querySelectorAll('input[type="range"]').forEach(slider => {
        const valueDisplay = document.getElementById(`${slider.id}Value`);
        if (valueDisplay) {
          // Set initial value
          valueDisplay.textContent = slider.value;
          
          // Update color based on value
          updateRangeColor(slider);
          
          // Add input event listener
          slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
            updateRangeColor(slider);
          });
        }
      });
    }
    
    // Update range slider background
    function updateRangeColor(slider) {
      const min = parseFloat(slider.min) || 0;
      const max = parseFloat(slider.max) || 1;
      const value = parseFloat(slider.value) || 0;
      const percent = ((value - min) / (max - min)) * 100;
      slider.style.setProperty('--value-percent', `${percent}%`);
    }
    
    function openSettingsModal() {
      try {
        console.log("Opening settings modal");
        
        // Initialize settings UI
        
        // Set reasoning method radio buttons
        const reasoningRadio = document.getElementById(`${REASONING_METHOD}Reasoning`);
        if (reasoningRadio) reasoningRadio.checked = true;
        
        // Set self-reflection toggle
        const selfReflectionToggle = document.getElementById('selfReflectionToggle');
        if (selfReflectionToggle) {
          selfReflectionToggle.checked = SELF_REFLECTION_ENABLED;
        }
        
        // Set parameter sliders
        setSliderAndValue("temp", TEMPERATURE);
        setSliderAndValue("topP", TOP_P);
        setSliderAndValue("maxTokens", MAX_TOKENS);
        setSliderAndValue("presencePenalty", PRESENCE_PENALTY);
        setSliderAndValue("frequencyPenalty", FREQUENCY_PENALTY);
        
        // Update CoD options UI if applicable
        if (REASONING_METHOD === 'cod') {
          const codOptions = document.getElementById('codOptions');
          if (codOptions) codOptions.style.display = 'block';
          updateCoDOptionsUI();
        }
        
        // Show modal
        const modal = document.getElementById("settingsModal");
        if (modal) modal.style.display = "flex";
        
        // Reset tab state
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // Hide all tabs first
        tabContents.forEach(content => {
          content.classList.remove('active');
          content.style.display = 'none';
        });
        
        // Deactivate all tab buttons
        tabButtons.forEach(btn => {
          btn.classList.remove('bg-primary-500', 'text-white');
          btn.classList.add('text-gray-400');
        });
        
        // Activate only the parameters tab by default
        const parametersTabBtn = document.querySelector('.tab-btn[data-tab="parametersTab"]');
        const parametersTab = document.getElementById('parametersTab');
        
        if (parametersTabBtn && parametersTab) {
          parametersTabBtn.classList.add('bg-primary-500', 'text-white');
          parametersTabBtn.classList.remove('text-gray-400');
          
          parametersTab.classList.add('active');
          parametersTab.style.display = 'block';
        }
        
        // Set web search toggle
        const webSearchToggle = document.getElementById('webSearchToggle');
        if (webSearchToggle) {
          webSearchToggle.checked = enableWebSearch;
        }
        
        // Set streaming toggle
        const streamingToggle = document.getElementById('streamingToggle');
        if (streamingToggle) {
          streamingToggle.checked = ENABLE_STREAMING;
        }
        
        console.log("Settings modal opened successfully");
      } catch (err) {
        console.error("Error in openSettingsModal:", err);
      }
    }
    
    function setSliderAndValue(id, value) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(`${id}Value`);
      
      if (slider) {
        slider.value = value;
        updateRangeColor(slider);
      }
      if (valueDisplay) valueDisplay.textContent = value;
    }
    
    function closeSettingsModal() {
      const modal = document.getElementById("settingsModal");
      if (modal) modal.style.display = "none";
    }
    
    function saveSettings() {
      try {
        console.log("Saving settings...");
        
        // Save previous settings for comparison
        const prevMethod = REASONING_METHOD;
        const prevWordLimit = COD_WORD_LIMIT;
        const prevEnhanced = SELF_REFLECTION_ENABLED;
        
        // Get streaming setting
        const streamingToggle = document.getElementById('streamingToggle');
        if (streamingToggle) {
          ENABLE_STREAMING = streamingToggle.checked;
          localStorage.setItem('streamingEnabled', ENABLE_STREAMING.toString());
          console.log(`Streaming preference saved: ${ENABLE_STREAMING}`);
        }
        
        // Get web search setting
        const webSearchToggle = document.getElementById('webSearchToggle');
        if (webSearchToggle) {
          enableWebSearch = webSearchToggle.checked;
          localStorage.setItem('webSearchEnabled', enableWebSearch.toString());
          console.log(`Web search preference saved: ${enableWebSearch}`);
        }
        
        // Save reasoning method
        try {
          const reasoningRadios = document.getElementsByName("reasoningMethod");
          for (const radio of reasoningRadios) {
            if (radio.checked) {
              REASONING_METHOD = radio.value;
              console.log("Reasoning method saved:", REASONING_METHOD);
              break;
            }
          }
        } catch (reasoningErr) {
          console.error("Error getting reasoning method:", reasoningErr);
        }
        
        // Save COD word limit if applicable
        if (REASONING_METHOD === "cod") {
          try {
            // Get the selected CoD word limit option
            const selectedOption = document.querySelector('.cod-word-limit-option.border-primary-500');
            if (selectedOption) {
              COD_WORD_LIMIT = parseInt(selectedOption.getAttribute('data-value'));
              console.log("COD word limit saved:", COD_WORD_LIMIT);
            }
          } catch (codErr) {
            console.error("Error getting COD word limit:", codErr);
          }
        }
        
        // Save self-reflection settings
        try {
          const selfReflectionToggle = document.getElementById('selfReflectionToggle');
          if (selfReflectionToggle) {
            SELF_REFLECTION_ENABLED = selfReflectionToggle.checked;
            console.log("Self-reflection enabled:", SELF_REFLECTION_ENABLED);
          }
        } catch (selfErr) {
          console.error("Error getting self-reflection settings:", selfErr);
        }
        
        // Save generation parameters safely with validation
        try {
          const tempSlider = document.getElementById("temp");
          if (tempSlider) {
            TEMPERATURE = parseFloat(tempSlider.value);
            if (TEMPERATURE === 0) TEMPERATURE = 0.01; // Ensure minimum value
          }
          
          const topPSlider = document.getElementById("topP");
          if (topPSlider) {
            TOP_P = parseFloat(topPSlider.value);
          }
          
          const presencePenaltySlider = document.getElementById("presencePenalty");
          if (presencePenaltySlider) {
            PRESENCE_PENALTY = parseFloat(presencePenaltySlider.value);
          }
          
          const frequencyPenaltySlider = document.getElementById("frequencyPenalty");
          if (frequencyPenaltySlider) {
            FREQUENCY_PENALTY = parseFloat(frequencyPenaltySlider.value);
          }
          
          const maxTokensSlider = document.getElementById("maxTokens");
          if (maxTokensSlider) {
            // Enforce model's max_tokens limits
            const rawMaxTokens = parseInt(maxTokensSlider.value);
            MAX_TOKENS = Math.min(Math.max(1, rawMaxTokens), 4096);
            
            // Update the slider and display if needed
            if (MAX_TOKENS !== rawMaxTokens) {
              maxTokensSlider.value = MAX_TOKENS;
              const valueDisplay = document.getElementById('maxTokensValue');
              if (valueDisplay) valueDisplay.textContent = MAX_TOKENS;
              console.log(`Adjusted max_tokens from ${rawMaxTokens} to ${MAX_TOKENS} to meet API requirements`);
            }
          }
          
          console.log("Parameters saved:", {TEMPERATURE, TOP_P, MAX_TOKENS, PRESENCE_PENALTY, FREQUENCY_PENALTY});
        } catch (paramsErr) {
          console.error("Error getting parameters:", paramsErr);
        }
        
        // Save tools settings
        try {
          const toolCheckboxes = document.querySelectorAll('input[name="tools"]');
          ENABLED_TOOLS = [];
          
          toolCheckboxes.forEach(checkbox => {
            if (checkbox.checked) {
              ENABLED_TOOLS.push(checkbox.value);
            }
          });
          
          localStorage.setItem('enabledTools', JSON.stringify(ENABLED_TOOLS));
          console.log("Enabled tools:", ENABLED_TOOLS);
        } catch (toolsErr) {
          console.error("Error getting tool settings:", toolsErr);
        }
        
        // Save settings to localStorage
        try {
          localStorage.setItem("reasoningMethod", REASONING_METHOD);
          localStorage.setItem("codWordLimit", COD_WORD_LIMIT.toString());
          localStorage.setItem("selfReflectionEnabled", SELF_REFLECTION_ENABLED.toString());
          localStorage.setItem("temperature", TEMPERATURE.toString());
          localStorage.setItem("topP", TOP_P.toString());
          localStorage.setItem("presencePenalty", PRESENCE_PENALTY.toString());
          localStorage.setItem("frequencyPenalty", FREQUENCY_PENALTY.toString());
          localStorage.setItem("maxTokens", MAX_TOKENS.toString());
          
          // Save custom prompts
          localStorage.setItem("customPrompts", JSON.stringify(PROMPTS));
          console.log("Settings saved to localStorage");
        } catch (storageErr) {
          console.error("Error saving to localStorage:", storageErr);
        }
        
        closeSettingsModal();
        
        // Show appropriate notification
        if (prevMethod !== REASONING_METHOD || 
            (REASONING_METHOD === "cod" && prevMethod === "cod" && prevWordLimit !== COD_WORD_LIMIT) ||
            prevEnhanced !== SELF_REFLECTION_ENABLED) {
          showNotification("Settings saved - reasoning method changed");
        } else {
          showNotification("Settings saved");
        }
      } catch (err) {
        console.error("Error in saveSettings:", err);
        showNotification("Error saving settings");
      }
    }
    
    /***********************
     * Mobile Navigation
     ***********************/
    function initMobileNavigation() {
      const mobileSidebarToggle = document.getElementById('mobileSidebarToggle');
      const mobileSidebar = document.getElementById('mobileSidebar');
      const closeMobileSidebar = document.getElementById('closeMobileSidebar');
      
      if (mobileSidebarToggle && mobileSidebar) {
        mobileSidebarToggle.addEventListener('click', () => {
          mobileSidebar.classList.remove('-translate-x-full');
          mobileSidebar.classList.add('translate-x-0');
        });
      }
      
      if (closeMobileSidebar && mobileSidebar) {
        closeMobileSidebar.addEventListener('click', () => {
          mobileSidebar.classList.remove('translate-x-0');
          mobileSidebar.classList.add('-translate-x-full');
        });
      }
      
      // Mobile buttons should trigger their desktop counterparts
      document.getElementById('mobileNewThreadBtn')?.addEventListener('click', () => {
        createNewThread();
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
      
      document.getElementById('mobileDeleteThreadBtn')?.addEventListener('click', () => {
        deleteCurrentThread();
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
      
      document.getElementById('mobileDownloadTxtBtn')?.addEventListener('click', () => {
        downloadCurrentThreadAsTxt();
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
      
      document.getElementById('mobileClearThreadBtn')?.addEventListener('click', () => {
        if (confirm("Clear all messages in this thread?")) {
          const thread = threads.find(t => t.id === currentThreadId);
          if (thread) {
            thread.messages = [];
            renderCurrentThreadMessages();
            showNotification("Thread cleared");
          }
        }
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
    }
    
    /***********************
     * Initialization
     ***********************/
    function loadPersistedSettings() {
      try {
        REASONING_METHOD = localStorage.getItem("reasoningMethod") || "cod";
        
        const codWordLimit = localStorage.getItem("codWordLimit");
        if (codWordLimit) COD_WORD_LIMIT = parseInt(codWordLimit);
        
        // Load self-reflection settings
        const selfReflectionEnabled = localStorage.getItem("selfReflectionEnabled");
        if (selfReflectionEnabled !== null) {
          SELF_REFLECTION_ENABLED = selfReflectionEnabled === "true";
        }
        
        // Load custom prompts if available
        const storedPrompts = localStorage.getItem("customPrompts");
        if (storedPrompts) {
          const parsedPrompts = JSON.parse(storedPrompts);
          // Merge with default prompts to ensure all properties exist
          PROMPTS = { ...PROMPTS, ...parsedPrompts };
        }
        
        const temp = localStorage.getItem("temperature");
        if (temp) TEMPERATURE = parseFloat(temp);
        
        const topP = localStorage.getItem("topP");
        if (topP) TOP_P = parseFloat(topP);
        
        const presencePenalty = localStorage.getItem("presencePenalty");
        if (presencePenalty) PRESENCE_PENALTY = parseFloat(presencePenalty);
        
        const frequencyPenalty = localStorage.getItem("frequencyPenalty");
        if (frequencyPenalty) FREQUENCY_PENALTY = parseFloat(frequencyPenalty);
        
        const maxTokens = localStorage.getItem("maxTokens");
        if (maxTokens) MAX_TOKENS = parseInt(maxTokens);
        
        // Load streaming preference
        const savedStreamingPref = localStorage.getItem('streamingEnabled');
        if (savedStreamingPref !== null) {
          ENABLE_STREAMING = savedStreamingPref === 'true';
        }
        
        // Load web search preference
        const webSearchEnabled = localStorage.getItem('webSearchEnabled');
        if (webSearchEnabled !== null) {
          enableWebSearch = webSearchEnabled === 'true';
        }
        
        // Load tools settings
        const enabledTools = localStorage.getItem('enabledTools');
        if (enabledTools) {
          try {
            ENABLED_TOOLS = JSON.parse(enabledTools);
          } catch (e) {
            console.error("Error parsing enabled tools:", e);
          }
        }
      } catch (err) {
        console.error("Error loading settings:", err);
      }
    }
    
    function initApp() {
      console.log("Initializing app...");
      
      try {
        loadPersistedSettings();
        console.log("Settings loaded");
        
        // Update CoD prompt with the correct word limit
        updateCoDPrompt();
        console.log("CoD prompt updated");
        
        createNewThread();
        console.log("New thread created");
        
        // Set up event listeners
        initEventListeners();
        console.log("Event listeners initialized");
        
        // Initialize mobile navigation
        initMobileNavigation();
        console.log("Mobile navigation initialized");
        
        // Add clear thread button event listener
        const clearThreadBtn = document.getElementById("clearThreadBtn");
        if (clearThreadBtn) {
          clearThreadBtn.addEventListener("click", () => {
            if (confirm("Clear all messages in this thread?")) {
              const thread = threads.find(t => t.id === currentThreadId);
              if (thread) {
                thread.messages = [];
                renderCurrentThreadMessages();
                showNotification("Thread cleared");
              }
            }
          });
          console.log("Clear thread button initialized");
        }
      } catch (err) {
        console.error("Initialization error:", err);
      }
    }
    
    function initEventListeners() {
      try {
        console.log("Initializing event listeners");
        
        // Helper function to safely add event listeners
        const addListener = (id, event, handler) => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener(event, handler);
          } else {
            console.warn(`Element with id "${id}" not found for event listener`);
          }
        };
        
        // Settings buttons
        addListener("openSettings", "click", openSettingsModal);
        addListener("closeSettings", "click", closeSettingsModal);
        addListener("closeModalX", "click", closeSettingsModal);
        addListener("saveSettings", "click", saveSettings);
        
        // Thread management
        addListener("newThreadBtn", "click", createNewThread);
        addListener("deleteThreadBtn", "click", deleteCurrentThread);
        addListener("downloadTxtBtn", "click", downloadCurrentThreadAsTxt);
        addListener("clearThreadBtn", "click", () => {
          if (confirm("Clear all messages in this thread?")) {
            const thread = threads.find(t => t.id === currentThreadId);
            if (thread) {
              thread.messages = [];
              renderCurrentThreadMessages();
              showNotification("Thread cleared");
            }
          }
        });
        
        // Web search toggle
        addListener("webSearchBtn", "click", toggleWebSearch);
        
        // Message input
        const textarea = document.getElementById('userInput');
        if (textarea) {
          textarea.addEventListener('input', () => {
            // Auto-resize textarea based on content
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
          });
          
          textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              document.getElementById('sendBtn')?.click();
            }
          });
        }
        
        // Send button
        addListener("sendBtn", "click", () => {
          const textarea = document.getElementById('userInput');
          if (textarea) {
            const message = textarea.value.trim();
            if (message || attachedFiles.length > 0) {
              sendMessage(message);
              textarea.value = '';
              textarea.style.height = 'auto';
            }
          }
        });
        
        // Initialize file upload
        handleFileInput();
        
        // Close modal when clicking outside
        window.addEventListener("click", (event) => {
          const settingsModal = document.getElementById("settingsModal");
          if (settingsModal && event.target === settingsModal) {
            closeSettingsModal();
          }
        });
        
        // Set up settings UI functionality
        setTimeout(() => {
          try {
            setupTabNavigation();
            setupCODOptions();
            setupToolsOptions();
            setupSliders();
            console.log("UI functionality setup complete");
          } catch (err) {
            console.error("Error setting up UI functionality:", err);
          }
        }, 100);
      } catch (err) {
        console.error("Error initializing event listeners:", err);
      }
    }
    
    // Initialize the application
    document.addEventListener("DOMContentLoaded", async function() {
      try {
        console.log("Starting application initialization...");
        
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
          if (event.matches) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        });
        
        // Initialize the app
        await initApp();
        console.log("Application initialized successfully");
        
        // Initialize Web search button state
        const webSearchBtn = document.getElementById('webSearchBtn');
        if (webSearchBtn && enableWebSearch) {
          webSearchBtn.classList.add('bg-primary-500', 'text-white');
          webSearchBtn.classList.remove('bg-dark-500', 'text-gray-300');
        }
        
      } catch (error) {
        console.error("Error during application initialization:", error);
        showNotification("Error initializing application. Please refresh the page.");
      }
    });
  </script>
</body>
</html>
